# dbbolton's zsh functions
# github.com/dbbolton
apn () {
#    su -lc 'aptitude -P install '"$@"' ' root
#     su -lc 'echo'  root
    cmd="su -lc 'aptitude -P install $@' root"
    print "$cmd"
    eval "$cmd"
}

# make a bzipped backup
bak () { # [input dir] [output file]
    # note the order of args
    print "tar cjf \"$2\" \"$1\""
    tar cjf "$2" "$1"
}

# test your font
font_test () {
    print "Letters:\tAaBbCcDdEeFfGgHhIiJjKkLlMm"
    print "\t\tNnOoPpQqRrSsTtUuVvWwXxYyZz"
    print "Digits:\t\t0123456789"
    print "Brackets:\t( ) [ ] { } < > "
    print "Quotes:\t\t\"foo\" 'bar' "
    print "Punctuation: \t, . ? : ; _ ! "
    print "Symbols:\t\` ~  @ # $ % ^ & * - + = | / \\"
    print "Ambiguity:\tIllegal1 = O0"
}

# guitar pro 5
gp5 () {
    cd '/home/dbb/.wine/drive_c/Program Files/Guitar Pro 5'
    wine 'GP5.exe' &
    cd -
}

# kernel building shortcut
dbb-build () {
    MAKEFLAGS=''
    appendage='-dbb-deb'
    revision=$(date +"%Y%m%d")

    make-kpkg clean

    time fakeroot make-kpkg --append-to-version "$appendage" --revision \
        "$revision" kernel_image kernel_headers
}

# Padawan's graph.
graph () {
    cd '/home/dbb/.wine/drive_c/Program Files/Graph'
    wine '/home/dbb/.wine/drive_c/Program Files/Graph/Graph.exe' &
    cd -
}

# is.gd url creator
isgd () { # [URL]
    url='http://is.gd/create.php?format=simple&url='"$1"
    curl "$url"
    printf "\n"
}

# When Iceweasel goes rabid
kiw () {
    kill $( pidof firefox-bin )
    killall firefox-bin
}

# Make a PDF from a man page.
man2pdf () { # [page name]
    man -t $1 | ps2pdf - > $1.pdf
}

# Make a dir and cd into it
md () { mkdir -p "$@"; if [[ -d "$@" ]]; then cd "$@"; fi  }


# Make a basic patch file.
mkpatch () { # [new file] [old file] [output file]
	diff -u "$1" "$2" > "$3"'.patch'

}

# My "development environment"
myde () { # [DIRECTORY]
    if [[ ! -d $1 ]]; then
        print "Bad dir name: '$1'" 
    else
        cd "$1"
        gvim +":cd $1" &
        [[ -d '.git' ]] && git status
    fi
}

# mupen64plus
m64 () {
    mupen64plus --osd --resolution 800x600 "$n64/$1" > /dev/null &
}

# ninja gaiden!
ng () {
    mednafen "$HOME/games/nes/Ninja_Gaiden_$1.nes"
}

# Perl stuff ################################################################

# print the latest stable version of Perl
latest_perl () {
    curl -s http://www.perl.org/get.html | \
        perl -wlne 'if (/perl\-([\d\.]+)\.tar\.gz/) { print $1; exit;}'
}

# create a perl document and open it for editing
newpl () {
    cp "$HOME/Templates/perl" "./$1"
    chmod +x "./$1"
    vim "$1" +4
}

# perl global substitution
pgs () { # [find] [replace] [filename]
    perl -i.bak -pe 's/'"$1"'/'"$2"'/g' "$3"
}


# Perl grep-- because 'grep -P' is terrible
prep () { # [pattern] [filename unless STDOUT]
    perl -nle 'print if '"$1"';' $2
}

# End Perl stuff ############################################################

# sagi - a find shortcut
sagi () { # [where] [what]
    [[ -n $1 && -n $2  ]] && find "$1" -iname "*$2*"
}

# say - append a newline to 'print'
say () {
    print "$@\n"
}

# to - makes it easier to cd to a variable that contains a path, e.g.
#   p="$HOME/some/long/ridiculous/path/name"
#   to p
to () {
    eval dir=\$$1; cd "$dir";
}

# vimprobable with tabs
#vpb () {
#    tabbed=$(tabbed -d); vimprobable2 -e $tabbed $*
#}

# Quick Find
qf () { 
	find . -maxdepth 2 -iname "*$1*" 
}

# unzip
uz () { # [archive] [dir]
	unzip -x $1 -d $2
}

# zsh calculator
zc () {
	for exp in $argv ; do
		print "$exp = $(( exp ))"
	done
}

